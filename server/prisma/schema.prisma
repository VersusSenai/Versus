generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int      @id @default(autoincrement())
  username        String   @db.VarChar(100)
  email           String   @unique @db.VarChar(100)
  password        String   @db.VarChar(255)
  role            Role
  registeredDate  DateTime @default(now()) @map("registered_date")
  eventInscriptions EventInscriptions[]
  teamUsers       TeamUsers[]
  status         UserStatus
  firstMatches   Match[] @relation("Match_firstUser")
  secondMatches  Match[] @relation("Match_secondUser")
  inviteTo        Invite[]  @relation("Invite_toUser")
  inviteFrom        Invite[] @relation("Invite_fromUser")
  applicationFrom        Application[] @relation("Application_fromUser")
}
enum UserStatus {
  A
  D
}
enum Role {
  P
  O
  A
}

model Event {
  id          Int      @id @default(autoincrement())
  name        String   @db.VarChar(100)
  description String  @db.VarChar(250)
  maxPlayers  Int     @db.Int
  startDate   DateTime @map("start_date")
  endDate     DateTime @map("end_date")
  model       Model
  status      Status   @default(P)
  matchsQuantity Int?
  keysQuantity Int?
  multiplayer Boolean
  private     Boolean? @default(false)
  eventInscriptions EventInscriptions[]
  matches      Match[]
  invites     Invite[] @relation("Invites_Event")


}

enum Model {
  P
  O
}

enum Status {
  //Ended
  E
  //On Going
  O
  // Pending (not started)
  P
}

enum TeamStatus { 
  // Approvation Pending
  P
  // Okay
  O
  // Banned
  B
  
}

model Team {
  id             Int      @id @default(autoincrement())
  name           String   @db.VarChar(100)
  description    String?  @db.VarChar(250)
  registeredDate DateTime @default(now()) @map("registered_date")
  teamUsers      TeamUsers[]
  private       Boolean? @default(false)
  EventInscriptions    EventInscriptions[]
  status         TeamStatus
  firstMatches   Match[] @relation("Match_firstTeam")
  secondMatches  Match[] @relation("Match_secondTeam")
  invites       Invite[] @relation("Invites_Team")
  status        TeamStatus
}

model EventInscriptions {
  id             Int      @id @default(autoincrement())
  userId         Int?
  teamId          Int?
  eventId        Int
  registeredDate DateTime @default(now()) @map("registered_date")
  status        InscriptionStatus @default(O)
  role          EventRole @default(P)
  user          User?     @relation(fields: [userId], references: [id],  onDelete: Cascade)
  event         Event    @relation(fields: [eventId], references: [id],  onDelete: Cascade)
  team           Team?  @relation(fields: [teamId], references: [id],  onDelete: Cascade)
  @@unique([userId, eventId])
  @@unique([teamId, eventId])
}

enum InscriptionStatus {
  //Okay
  O
  //Lost
  L
  //Winner
  W
  //Removed
  R
}

enum EventRole {
  //Owner
  O
  //Player
  P
}

enum TeamInscription {
  //Okay
  O
  //Banned
  B
}

enum TeamRole {
  //Admin
  A 
  // Owner
  O 
  // Player
  P
}

model TeamUsers {
  id              Int      @id @default(autoincrement())
  userId          Int @unique
  teamId          Int
  inscriptionDate DateTime @default(now()) @map("inscription_date")
  status         TeamInscription @default(O)
  role            TeamRole @default(P)
  user           User @relation(fields: [userId], references: [id],  onDelete: Cascade)
  team           Team @relation(fields: [teamId], references: [id],  onDelete: Cascade)
}


model Match {
  id          Int      @id @default(autoincrement())
  eventId     Int
  keyNumber   Int
  firstTeamId Int?
  secondTeamId Int?
  firstUserId Int?
  secondUserId Int?
  time        DateTime?
  winnerId    Int?
  loserId     Int?
  event       Event @relation(fields: [eventId], references: [id],  onDelete: Cascade)
  firstTeam   Team?  @relation(fields: [firstTeamId], references: [id], name: "Match_firstTeam",  onDelete: Cascade)
  secondTeam  Team?  @relation(fields: [secondTeamId], references: [id], name: "Match_secondTeam",  onDelete: Cascade)
  firstUser   User?  @relation(fields: [firstUserId], references: [id], name: "Match_firstUser",  onDelete: Cascade)
  secondUser  User?  @relation(fields: [secondUserId], references: [id], name: "Match_secondUser",  onDelete: Cascade)
}

enum InviteStatus {
  //Pending
  P 
  //Accepted
  A
  //Denied
  D
  //Expired
  E
}

model Invite {
  id          Int      @id @default(autoincrement())
  fromUserId  Int
  toUserId    Int
  description String
  token       String
  expirationDate DateTime
  status  InviteStatus
  callback  String?
  teamId     Int? 
  eventId     Int? 
  toUser    User  @relation(fields: [toUserId], references: [id], name: "Invite_toUser", onDelete: Cascade)
  fromUser    User  @relation(fields: [fromUserId], references: [id], name: "Invite_fromUser", onDelete: Cascade)
  event     Event?  @relation(fields: [eventId], references: [id], name: "Invites_Event", onDelete: Cascade) 
  team     Team?  @relation(fields: [teamId], references: [id], name: "Invites_Team", onDelete: Cascade) 


}

enum ApplicationType {
  //To became an event organizer
  O

}


model Application {
    id          Int      @id @default(autoincrement())
    fromUserId  Int
    fromUser    User  @relation(fields: [fromUserId], references: [id], name: "Application_fromUser", onDelete: Cascade)
    applicationType ApplicationType
    Description  String
    status  InviteStatus @default(P)
    applicationDate DateTime @default(now()) @map("applicationDate")
    
}